# class for boxes generated by forward models
import scipy.io as sio
import numpy as np
from time import time

class pyBox(object):
    def __init__(self,attr_dict):

        # set attributes from attribute dictionary
        for attr_name in attr_dict:
            setattr(self,attr_name,attr_dict[attr_name])

        # check for required attributes
        self.initialized=True
        required=['path','boxobj']
        for req in required:
            try:
                getattr(self,req)
            except AttributeError:
                print('pyBox initialization error!')
                print(req + " attribute doesn't exist")
                self.initialized=False

        if self.initialized:
                print('pyBox initialization successful.')

        return

    def loadBox(self):
        ''' loads in a matlab objection using sio.loadmat and sets some attributes
            for easier access to useful parameters
        '''
        t0 = time()
        fi=self.path+'/'+self.boxobj
        print('loading box file '+fi)
        b=sio.loadmat(fi,squeeze_me=True,struct_as_record=False)
        print(str(time()-t0)+' seconds to load')
        #hoozit = sio.whosmat(path+matobj) # get a little info without loading it..
        #print(hoozit)
        self.box = b['Box']
        print('box is a ' + str(type(self.box)) + ', with shape:')
        print(self.box.shape)

        self.n_var1 = self.box.shape[0]
        self.n_var2 = self.box.shape[1]

        print("\nBox fieldnames:")
        print(self.box[0,2]._fieldnames)
        print(self.box[0,2].info._fieldnames)
        print(self.box[0,2].run_info._fieldnames)

        # pull out some of the box info into more accessible attributes
        print('set var2 dict')
        self.var2={'range':self.box[0,0].info.var2range,
                    'name':self.box[0,0].info.var2name,
                    'units':self.box[0,0].info.var2units}
        print('set var1 dict')
        self.var1={'range':self.box[0,0].info.var1range,
                    'name':self.box[0,0].info.var1name,
                    'units':self.box[0,0].info.var1units}
        self.f_band = self.box[0,1].Frames[-1].VBR.input.SV.f # frequency band:

        return


    def f_band_limits(self,min_val,max_val,period_or_freq):
        ''' finds the indeces and values of frequency closest to the min and max
            values supplied in the arguments. Can give min and max values as
            frequency or period (if period_or_freq is 'period', then min_val and
            max_val are treated as periods)
        '''
        # get min, max frequency
        if period_or_freq=='period':
            f_bw_min = 1/max_val
            f_bw_max = 1/min_val
        else:
            f_bw_min = min_val
            f_bw_max = max_val

        # find the index of frequency value closest to the min and max:
        print("\nFinding subset frequency band in: ["+str(f_bw_min)+','+
              str(f_bw_max)+'].')
        fmin = self.f_band[self.f_band>=f_bw_min][0]
        fmax = self.f_band[self.f_band<=f_bw_max][-1]
        i_fmax = int(np.where(self.f_band==fmax)[0])
        i_fmin = int(np.where(self.f_band==fmin)[0])
        print('Subset frequency band and indexes:')
        print(fmin,fmax,i_fmin,i_fmax)

        return fmin,fmax,i_fmin,i_fmax
