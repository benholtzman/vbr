How to fit your seismic observables:
This doc describes the current workflow.  Anything with an * indicates that it
could/should be updated in the future.

This doc contains more detail and pulls information from various comments
together, though just stepping section-by-section through the code
fit_seismic_observations() should be pretty self-explanatory.


############## 1. Get prior for Vs(x, f) and Q(x, f) ##############
This section loads in the seismic observations, and extracts the observed
data point, its standard deviation, and calculates a prior pdf assuming a
normal distribution.

The seismic observations are assumed to be saved in some file, xxxx.mat,
that contains a single variable (name irrelevant, as it is renamed to Model)
[obs_name]_Model    structure with the following fields
   Latitude    n_lat vector of latitude points [degrees N]
   Longitude   n_lon vector of longitude points [degrees E]
                (can be negative - code will add 360 degrees to negative values)
  Depth        n_dep vector of depth points [km]
  [obs_name]  (n_lat, n_lon, n_dep) matrix of values of this
               seismic property based on observations
  Error       (n_lat, n_lon, n_dep) matrix of uncertainty of this seismic
              property based on observations. This is often not reported!
              As such, if there is no such field in the saved .mat file,
              a default value is assumed, with a message printed to screen.

--- Things you should change:
      - location.lat, location.lon - (lat, lon) of your desired point
      - location.z_min, location.z_max - depth range from which to extract
          the observed data, i.e. asthenospheric depth range
          * Currently just set up front, though we could go back to plotting
          the Vs or Q profile and picking the depth range on the figure
      - vsfile, qfile - the filenames of the saved seismic observations in the
          format described above
      - If you only want to fit Vs or Q, comment out/delete the other call
          to process_SeismicModels()
--- Functions called:
      - functions/process_SeismicModels()
          This returns the prior pdf, observed value and standard deviation
          given an input location and model file
--- Returns:
      - prior_[Vs|Qinv]   prior probability assuming a normal distribution
      - obs_[Vs|Qinv]     value of seismic observation at location
      - sigma_[Vs|Qinv]   standard deviation of seismic observation at location


############## 2. Get prior for State Variables ##############
This section preferably loads in a previously calculated sweep across a
range of values of T, phi, gs and calculates the average Vs and Qinv across
all depths (well, 0-300 km) for the given frequency range.  If no such sweep
has been saved, it will calculate a fresh one.  It then calculates a prior
probability for each variable, assuming some form of pdf across the range of
each of the state variables.
* At the moment, the only option is to give a vector of values (though could
be of length 1) for each of T, phi, gs - and there is no possibility to vary
any other parameter.  Could update this to be more flexible.

--- Things you should change:
      - fname - the file name of your previously calculated sweep
      - If you want to recalculate, alter the variables in the if statement
          sweep_params.T - vector of possible temperatures, [degrees C]
                            (note not potential temperature)
          sweep_params.phi - vector of possible melt fractions
          sweep_params.gs - vector of possible grain sizes [μm]
          sweep_params.per_bw_max, per_bw_min - the period range of interest [s]
      - qmethod - attenuation method for anelastic calculations
      - pdf_type - set to {'uniform'} or {'normal'} (or with a cell of length 3,
          you could set different pdf types for each of T, phi, gs)
--- Functions called:
      - functions/generate_parameter_sweep()
          Calculate a big parameter sweep if you don't already have one saved
      - functions/extract_values_in_depth_range()
          This pulls the VBR calculated values from the parameter sweep given
          some Q method and a depth range.
      - functions/make_param_grid()
          This reformats the structure 'sweep' into something easier to work
          with for calculating the prior pdf - grids the vectors of parameters
          and calculates a mean and standard deviation for the parameter range.
          Note that if your pdf_type = {'uniform'}, this mean and std will not
          be used.  You can also manually change these after calling this
          function and before calling priorModelProbs()
      - ../vbr/6_FitVobs/matlab_FittingFunctions/priorModelProbs()
          This calculates the joint prior pdf of the state variables according
          to the input pdf_type and assuming that all of the state variables
          are independent of each other
            i.e. p(T=T0, phi=phi0, gs=gs0) = p(T=T0) * p(phi=phi0) * p(gs = gs0)
-- Returns:
      - prior_statevars   prior probability of the state variables assuming
                          the distribution given in pdf_type
      - sigma_statevars   the standard deviation of the state variables
          * I am not sure this combined sigma is calculated correctly in
          priorModelProbs() - see comment starting line 80 in that file for what
          I think the actual formula is.  I am also not sure why it is useful to
          have - it is used to scale the posterior pdf later, and I don't know
          where that scaling equation comes from.

############## 3. Get likelihood for Vs, Q ##############
Likelihood is the probability of getting the observed Vs or Q given the assumed
state variable values.
The likelihood p(D|A), e.g., P(Vs | T, phi, gs), is calculated using
the residual (See manual, Menke book Ch 11):
     p(D|A) = 1 / sqrt(2 * pi * residual) * exp(-residual / 2)
residual(k) here is a chi-squared residual. Given chi-square, the PDF
of data with a normal distribution:
     P = 1 / sqrt(2 * pi * sigma^2) * exp(-0.5 * chi-square)
where sigma = std of data, chi-square=sum((x_obs - x_preds)^2 / sigma^2)
e.g. www-cdf.fnal.gov/physics/statistics/recommendations/modeling.html

--- Things you should change:
      - If you only want to fit Vs or Q, comment out/delete the other call to
        calculate_likelihood_from_residual()
-- Functions called:
      - functions/calculate_likelihood_from_residual()
          This takes the observed value and standard deviation of the seismic
          property and compares it to the calculated value across all the
          combinations of the state variables that have been calculated to
          return the likelihood based on the formula described above.
-- Returns:
      - likelihood_[Vs|Qinv]  (n_T, n_phi, n_gs) matrix of the likelihood of
                               Vs or Qinv given the relevant combination of
                               the state variables

############## 4. Get posterior for State Variables ##############
Calculate the posterior probablity in a Bayesian way - p(S|D) = p(D|S)p(S)/p(D)
and then plot it.  This is for Q and Vs individually.
* Also scale the posterior by some factor that comes from somewhere....? Need
to at the very least take out my sceptical comment.

--- Things you should change:
      - If you only want to fit Vs or Q, comment out/delete the relevant lines
--- Functions called:
      - plot_Bayes()
          Plot the posterior pdf
--- Returns:
      - [sc_]posterior_S_given_[Vs|Qinv]  (n_T, n_phi, n_gs) matrix of the
                                          (scaled) posterior probability of the
                                          state variables given Vs or Qinv
      - A figure showing the posterior pdf given Vs or Qinv

########### 5. Get posterior for State Variables given both Vs and Q ###########
Calculate the posterior in a joint sense given constraints from both Vs and Q.
We cannot calculate the absolute probability because we do not know p(Vs, Qinv).
However, for a given location (i.e. fixed Vs and Qinv), we can assume that this
is a constant scaling and just remove it from our calculation.  In which case,
    p(S | (Vs, Qinv)) ∝ p(Vs | S) * p(Qinv | S) * p(S)
(see Manual).

--- Things you should change:
      - If you only want to fit Vs or Q, don't run this section.  If you want
        to go on to use RF constraints (remaining part of code), you will need
        to run find_best_state_var_combo() using a posterior pdf from Sect. 4.
--- Functions called:
      - plot_Bayes()
          Plot the posterior pdf
      - find_best_state_var_combo()
          Loop through temperature to find the best combinations of melt
          fraction and grain size to maximise the posterior at each T.
--- Returns:
      - posterior_S_given_Vs_and_Qinv   (n_T, n_phi, n_gs) matrix of the
                                        posterior probability of the state
                                        variables given both Vs and Qinv
      - best_T_g_phi                    (n_T, 3) matrix of the state variable
                                        combination that maximimises the
                                        posterior for each T
      - posterior_T                     (n_T, ) of the max posterior probability
                                        for each temperature

####### You can stop here if you don't want to add in RF constraints #######


########### 6. Get prior for LAB from RFs ###########
This is exactly equivalent to section 1, except LAB depth is not a function of
z, so that field is not expected to be included in xxxx.mat.  The variable
'location' is also assumed to have been set in section 1.
This section loads in the seismic observations, and extracts the observed
data point, its standard deviation, and calculates a prior pdf assuming a
normal distribution.

The seismic observations are assumed to be saved in some file, xxxx.mat,
that contains a single variable (name irrelevant, as it is renamed to Model)
[obs_name]_Model    structure with the following fields
   Latitude    n_lat vector of latitude points [degrees N]
   Longitude   n_lon vector of longitude points [degrees E]
                (can be negative - code will add 360 degrees to negative values)
  [obs_name]  (n_lat, n_lon, n_dep) matrix of values of this
               seismic property based on observations
  Error       (n_lat, n_lon, n_dep) matrix of uncertainty of this seismic
              property based on observations. This is often not reported!
              As such, if there is no such field in the saved .mat file,
              a default value is assumed, with a message printed to screen.

--- Things you should change:
      - labfile - the filename of the saved seismic observations in the
          format described above
--- Functions called:
      - functions/process_SeismicModels()
          This returns the prior pdf, observed value and standard deviation
          given an input location and model file
--- Returns:
      - prior_LAB   prior probability assuming a normal distribution
      - obs_LAB     value of seismic observation at location
      - sigma_LAB   standard deviation of seismic observation at location

########### 7. Get prior for Tpot, zPlate ###########
*Need to update this so it loads in a previously calculated VBR box for the
sake of the geotherms, then updates the calculated Q given the parameter
combinations found in Sect 5 (best_T_g_phi).
Convert from T to Tpot and update the values of melt fraction and grain
size according to best_T_g_phi, then calculate the seismic LAB depth
based on the output attenuation structure.  Use this (and the previously
calculated pdf for temperature (i.e. Tpot)) to calculate the prior.

--- Things you should change:
      - If you want to recalculate,
          LABsweep.zPlatekm - vector of zPlate, [km]
          LABsweep.Tpot - do not change! Needs to correspond to sweep.T!
      - For calculating the seismic LAB from the attenuation structure
          LAB_settings.per_bw_max, per_bw_min - the period range of interest [s]
          LAB_settings.q_method - currently set to match q_method from before
      - pdf_types - should leave the first value as 'input', which makes the
          code look for an input pdf for Tpot, but can change the zPlatekm
          pdf type to 'normal' or 'uniform'
--- Functions called:
      - functions/generate_boxes_ThermalEvolution() *
          this should be replaced by loading in precalculated geotherm boxes
          and then pulling out the ones that are relevant to our desired Tpot
          and zPlatekm ranges
      - functions/process_ThermalEvolution_vbr() *
          If your box was big enough, could just find the values that combined
          the parameters in the right way - or leave this in to recalculate.
      - ../vbr/6_FitVobs/matlab_FittingFunctions/calc_LAB_Vs()
          Given a VBR box and the desired period range and Q method (passed via
          LAB_settings), calculate the predicted seismic LAB depth.
     - functions/make_param_grid()
         This reformats the structure 'sweep' into something easier to work
         with for calculating the prior pdf - grids the vectors of parameters
         and calculates a mean and standard deviation for the parameter range.
         Note that we are manually setting the params.TpC_pdf to be the
         posterior pdf that we calculated in Sect 6 (or 5), i.e. it contains
         the constraints from the Vs and Q (or only one of them) already.
     - ../vbr/6_FitVobs/matlab_FittingFunctions/priorModelProbs()
         This calculates the joint prior pdf of the state variables according
         to the input pdf_type and assuming that all of the state variables
         are independent of each other
           i.e. p(Tpot=Tpot0, zPlate=zPlate0) = p(Tpot=Tpot0) * p(zPlate=zPlate0)

########### 8. Get likelihood for LAB ###########
Likelihood is the probability of getting the observed Vs or Q given the assumed
state variable values.
The likelihood p(D|A), e.g., P(Vs | T, phi, gs), is calculated using
the residual (See manual, Menke book Ch 11):
     p(D|A) = 1 / sqrt(2 * pi * residual) * exp(-residual / 2)
residual(k) here is a chi-squared residual. Given chi-square, the PDF
of data with a normal distribution:
     P = 1 / sqrt(2 * pi * sigma^2) * exp(-0.5 * chi-square)
where sigma = std of data, chi-square=sum((x_obs - x_preds)^2 / sigma^2)
e.g. www-cdf.fnal.gov/physics/statistics/recommendations/modeling.html

--- Things you should change:
      - N/A
-- Functions called:
      - functions/calculate_likelihood_from_residual()
          This takes the observed value and standard deviation of the seismic
          property and compares it to the calculated value across all the
          combinations of the state variables that have been calculated to
          return the likelihood based on the formula described above.
-- Returns:
      - likelihood_LAB    (n_Tpot, n_zPlate) matrix of the likelihood of LAB
                          given the relevant combination of the state variables

############## 9. Get posterior for Variables ##############
Calculate the posterior probablity in a Bayesian way - p(V|D) = p(D|V)p(V)/p(D)
and then plot it.  This is for LAB constraints only as D, given that the
constraints from Vs and Q are already included in the posterior on Tpot.

--- Things you should change:
      - N/A
--- Functions called:
      - plot_Bayes()
          Plot the posterior pdf
--- Returns:
      - posterior_vars_given_LAB    (n_Tpot, n_zPlate) matrix of the
                                    posterior probability of the variables
                                    given LAB depth, Vs and Qinv constraints
      - A figure showing the posterior pdf given Vs, Qinv, and LAB depth
